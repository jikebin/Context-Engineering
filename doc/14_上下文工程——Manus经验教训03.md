# 遮蔽而非移除：Agent工具选择的工程智慧

## 背景：常规做法（RAG for Tools）
当工具过多时，最直观的做法是按需动态加载最相关的工具到Prompt中。

## 问题：生成级陷阱

* 性能杀手：动态修改前缀，导致KV缓存失效。
* 幻觉诱因：上下文逻辑不一致，诱发错误。

## Manus的做法概述（解决方案）

采用性能优先的“只追加”架构，通过“响应预填充”与“约束解码”技术，实现动态、可靠的工具选择。

## 预填充工作原理：结构与模式

### 1.消息结构：对话的“剧本”

我们发送给模型的不是随意文本，而是遵循特定格式（如Hermes格式）的结构化对话历史：
```llm
<|im_start|>system
[...所有工具定义...]
<|im_end|>
<|im_start|>user
[...用户提问...]
<|im_end|>
<|im_start|>assistant
[这是我们“预填充”的核心操作区域]
```

### 2.核心原理：强大的“模式延续者”

大模型的本质是根据前面的文本序列，预测下一个最可能的词。它在海量训练中学习了无数种“模式”。

“**响应预填充**”正是利用了这一点：我们主动提供一个强烈的“**模式信号**”（如`<tool_code>`）,来激活模型内部与该模式最匹配的生成路径。

配合“**约束解码**”，就能将高概率的“引导”升级为100%的“强制”。

## 实现细节：三种预填充模式示例

通过在助手回复位置（`<...>assistant`）预先拼接不同文本，我们可以精确引导模型行为。下面是最终发给模型的完整Prompt中的关键部分：

| 模式 | 用户输入 & 响应预填充 & 模型输出 |
| ----  | -----  | 
| 自动（Auto）  | 用户输入：你好，帮我查查今天有什么新闻？<br>响应预填充：`<...>assistant`<br>模型输出（可能）：好的，正在为您查找今日新闻...  | 
| 必须（Required）  | 用户输入：帮我查下北京今天的天气。<br>响应预填充：`<...>assistant<tool_code>`<br>模型输出（强制）：`get_weather(city="北京")`  | 
| 指定(Specific)  | 用户输入：用浏览器搜索一下AI Agent的最新进展。<br>响应预填充：`<...>assistant<tool_code>browser_search(`<br>模型输出(强制)：`query="AI Agent的最新进展")` | 

## 逻辑脉络回顾与最终收益

### 1.背景与挑战
Agent需灵活使用多工具，但常规做法(RAG)存在性能与逻辑两大问题。

### 2.Manus多做法
采用性能优先的“只追加”架构，通过“响应预填充”与“约束解码”实现精确控制。

### 3.核心受益
以绩效灵活性为代价，换取了**低延迟、低成本、高可靠性**，完成从“请求” 到 “命令” 的范式转变。