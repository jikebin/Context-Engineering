# 上下文隔离：多Agent协作的两种架构模式

问题的提出：多Agent系统的“噩梦”

>多Agent系统虽强大，但让他们之间高效、无误地同步信息，是一场噩梦。这本质上是经典的多线程通信问题。

## 核心类比：借鉴Go语言并发哲学

* 不要通过共享上下文来通信
* 而要通过通信来共享上下文

## 模式一：通过通信

核心思想：上下文不共享。子Agent就像一个一次性的“黑盒工具人”。

### 工作流程

1. 主Agent生成工具调用，如`code_searcher(query="...")`
2. 框架创建全新的、干净的子Agent,其上下文只包含该指令。
3. 子Agent的最终产出，作为Observation返回给主Agent。

优点：轻量、高效、隔离性好、成本低。
缺点：缺乏历史视野。

具体例子：Superviser 模式

## 模式二：通过共享上下文

核心思想：上下文只读共享。子Agent拥有完整的历史视野，但以一个全新的“身份” 和 “技能包” 来行动。

### 工作流程

1. 主Agent发出“分叉(Fork)”动作。
2. 框架为一次全新的LLM调用构建Prompt:子Agent的新System Prompt + 主Agent的完整历史。
3. 子Agent独立完成任务，结果返回Agent。

优点：能处理高度依赖历史的复杂任务。
缺点：昂贵！
* 输入Token花费更多：因为需要预填充完整的历史记录。
* KV缓存完全失效：因为更换了System Prompt,无法重用缓存。

具体例子：群里架构 或 Swarm 架构。

## 总结与启示

### 架构选择的衡量

* 通讯模式适用场景：任务有一个简短、清晰的指令。并且只关心最终输出。
* 例如：在代码库中搜索特定代码片段。
* 共享上下文模式适用场景：更复杂的场景，最终报告依赖于大量中间过程和历史笔记。
* 例如：进行一次深度研究并撰写报告。

### 给产品和开发的启示

在设计多Agent系统时，必须清醒的认识到两种模式的成本与收益。

### 默认应优先考虑更轻量的“通信模式”。只有在任务确实需要完整历史背景时，才谨慎地使用“共享上下文模式”，并为其带来的更高延迟和成本做好准备。